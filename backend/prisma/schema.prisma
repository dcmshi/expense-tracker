// Prisma schema — Mobile Expense Tracker
// Database: PostgreSQL
// Migrations: prisma migrate dev
//
// Note: CHECK constraints (source, processing_status, confidence range,
// amount > 0, currency length) are not supported by Prisma schema syntax.
// They are added manually to the generated migration SQL after creation.
//
// Note: updated_at is managed by Prisma's @updatedAt at the application
// layer. Direct SQL updates outside of Prisma will not trigger this.

generator client {
  provider        = "prisma-client"
  output          = "../generated/prisma"
  previewFeatures = ["partialIndexes"]
}

datasource db {
  provider = "postgresql"
  // url is configured in prisma.config.ts (Prisma 7)
}

// ------------------------------------------------------------
// EXPENSE
// Central record for all expense entries regardless of source.
// processing_status lifecycle:
//   manual:          created directly as 'verified'
//   receipt / voice: uploaded → processing → parsed → awaiting_user → verified
//                                                   ↘ failed
// ------------------------------------------------------------

model Expense {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id           String?  @db.Uuid        // nullable — reserved for future multi-user support
  amount            Decimal? @db.Decimal(12, 2) // null for receipt/voice drafts until parsed
  currency          String   @default("CAD") @db.VarChar(3)  // ISO 4217
  merchant          String?
  category          String?
  date              DateTime? @db.Date        // null for receipt/voice drafts until parsed
  notes             String?
  source            String   @db.VarChar(10) // CHECK: manual | voice | receipt (enforced in migration)
  receipt_url       String?
  raw_input         Json     @default("{}")  // receipt: { ocr_text, line_items } | voice: { transcript }
  confidence        Decimal? @db.Decimal(4, 3) // null in Phase 1 for non-manual; 1.0 for manual
  is_user_verified  Boolean  @default(false)
  processing_status String   @db.VarChar(20) // CHECK: uploaded | processing | parsed | awaiting_user | verified | failed
  created_at        DateTime @default(now()) @db.Timestamptz
  updated_at        DateTime @default(now()) @updatedAt @db.Timestamptz

  processing_jobs ProcessingJob[]

  @@index([created_at(sort: Desc)], name: "idx_expenses_created_at")
  @@index([processing_status], name: "idx_expenses_processing_status")
  @@map("expenses")
}

// ------------------------------------------------------------
// UPLOAD
// Tracks presigned URL requests for direct-to-S3 uploads.
// Supports idempotency on POST /uploads — duplicate requests
// within the URL TTL return the existing record.
// ------------------------------------------------------------

model Upload {
  upload_id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  object_key               String
  idempotency_key          String   @unique @db.VarChar(255)
  presigned_url_expires_at DateTime @db.Timestamptz
  created_at               DateTime @default(now()) @db.Timestamptz

  @@map("uploads")
}

// ------------------------------------------------------------
// PROCESSING JOB
// One job per ingestion request. Tracks worker execution state,
// retry count, and error history. Idempotency key ties the job
// back to the originating POST /ingest/receipt request.
// ------------------------------------------------------------

model ProcessingJob {
  job_id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  expense_id         String   @db.Uuid
  status             String   @db.VarChar(20) // CHECK: same states as expenses.processing_status
  attempt_count      Int      @default(0)
  max_attempts       Int      @default(3)
  last_error_message String?
  idempotency_key    String   @unique @db.VarChar(255)
  created_at         DateTime @default(now()) @db.Timestamptz
  updated_at         DateTime @default(now()) @updatedAt @db.Timestamptz

  expense Expense @relation(fields: [expense_id], references: [id], onDelete: Cascade)

  @@index([expense_id], name: "idx_processing_jobs_expense_id")
  // Partial index: only active jobs indexed — shrinks over time as most
  // jobs accumulate in terminal states (verified, failed)
  @@index([created_at(sort: Asc)], name: "idx_processing_jobs_active_status", where: raw("status IN ('uploaded', 'processing')"))
  @@map("processing_jobs")
}
